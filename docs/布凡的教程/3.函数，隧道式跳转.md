# 3.函数，隧道式跳转

这一章，将引入新的内容——函数，以及跳转的一种进阶用法。



## 函数

在你的印象里，数学意义上的函数好像就是那种，y=x+1，这样的表达式，但是在编程当中，函数的功能将更加强大。

有一种形容非常贴切这种描述，函数就像一台加工机器，只要你放进原料，它就会吐出成品。值得一提的是，放入的原料，包括让它干的事情可以不是固定的，比如一个包包子的机器，你放入了面粉做的白色面皮，也可以放掺了菜汁的绿色面皮；再放入猪肉的馅料，当然你也可以放菜肉的馅料；最后还可以设定机器包几个包子，包哪种包子。总之，这里强调的是，一个函数不仅仅能够处理一个问题，它能够处理的是一类问题，从而帮助你省掉很多麻烦。





用如下代码新建一个函数：

```
== function <函数名>(<参数1>,<参数2>,......) ==
```

函数名最好不要和某一个变量或者其他函数重名。

参数可以填很多个，中间使用半角逗号隔开，还可以不填任何参数，但是一定要在函数名的末尾加上一堆括号。

你可以将参数理解为只能在函数内使用的变量，参数的作用域在该函数内（即参数在函数外部无效），一个参数的名字不能最好不要和所在函数中，所引用的其他变量或是函数重名。

```
//举例：
== function han_shu_1() ==
......
== function han_shu_2(x) ==
......
== function han_shu_3(hp,int) ==
......
```



函数里面和函数外面能够实现的功能大部分相同，函数内的代码也会对外部造成影响。

函数无法直接输出普通文本，即在玩家的屏幕上显示出什么。

函数能够放在任何位置，但我建议你在左上角创建一个文件，而后将所有函数都统一放在里面。

想引用变量一样，你可以在任何地方引用一个函数（包括这个函数内部，这样你就做出了一个循环）



以下是一个实现加血的函数：

```
main.ink
```

```
//以下是文件main.ink，也就是你打开编辑器后所处在的文件
INCLUDE gyc.ink
INCLUDE array.ink
INCLUDE fn.ink       //此处将新建的文件fn.ink引入


VAR health = 50      //假设现在的血量是50/100
VAR max_health = 100
~ add_health(50)
你现在的血量是:{health}





```

```
fn.ink
```

```
//以下是新建的一个文件fn.ink用来放函数
== function add_health(value) ==
{ value + health <= max_health:
      ~ health = health + value
  else:
      ~ health = max_health
}
```

再这个例子中，当游戏刚刚开始，针出现在main.ink文件的第一行，而后向下移动，当移动到第4行时，系统看到了文件fn.ink，这就意味着，在之后，无论是跳转还是引用，文件fn.ink都可以被系统检索到。

而后针移动到7，8两行，定义了全局变量“health”以及“max_health”。

之后，系统来到了第9行，于是系统开始在main.ink以及之前include过的文件fn.ink内寻找”add_health“这个函数。

系统在fn.ink中发现了”== function add_health(value) ==“，于是便从这一行开始向下运行，同时从上面的”~ add_health(50)“中找到50，将50赋值给参数value，于是在这个函数内，value的值就是50了。

由于value + health <= max_health这个条件成立，因此针跳转到fn.ink的第4行，为全局变量health赋值。

接下来，由于针进入了fn.ink的第4行后，也就是条件分支的末端，其向下无路可走（之所以不能移动到第5行而后接着向下是因为两者不属于同一条分支），于是系统认为这次调用函数add_health已经完成，于是回到原来的位置main.ink文件的第9行接着向下走。

针来到了第10行，输出文字 ”你现在的血量是:{health}“ 其中{health}变量被调用，由于经过~ add_health(50)的赋值，health的值由原来的50变成了100，因此真正输出的文字是 ”你现在的血量是:50“





函数的返回值能够将return后面的东西送回调用函数的地方：

```
main.ink
```

```
//以下是文件main.ink，也就是你打开编辑器后所处在的文件
INCLUDE gyc.ink
INCLUDE array.ink
INCLUDE fn.ink       //此处将新建的文件fn.ink引入


VAR max_health = 100
升级！你现在的血量上限是:{add_max_health_and_print_it(50)}     //这里为了方便理解，因此函数名字设定得比较长，实际应用中只要自己理解即可，过长的名字会导致阅读困难。





```

```
fn.ink
```

```
//以下是新建的一个文件fn.ink用来放函数
== function add_max_health_and_print_it(value) ==
~ max_health = max_health + value
~ return max_health
```

这里，函数先将max_health 赋值为 max_health + value，而后将其送回调用函数的位置，因此当针从函数里面出来并回到main.ink的第8行时，原来是add_max_health_and_print_it(50)的地方会变成max_health:



升级！你现在的血量上限是:{add_max_health_and_print_it(50)} 

|

V

升级！你现在的血量上限是:{max_health} 



而后系统将这句话呈现到玩家屏幕上时就会是”升级！你现在的血量上限是:150“





还记得在第一篇教程中让屏幕不断重复出现111，222，333，111，222，333，111，222，333，111.........的代码吗？

函数也可以构建循环，其依靠的原理是，函数内部也可以调用函数。

下面举一个例子，计算1~100的和:

```
main.ink
```

```
INCLUDE gyc.ink
INCLUDE array.ink
INCLUDE fn.ink     

1~100的和是:{a(1,0)}





```

```
fn.ink
```

```
== function a(i,sum) ==
{ i <= 100:
      ~ return a(i+1,sum+i)
  else:
      ~ return sum
}
```

这个函数的意思是，如果参数i 小于等于100，那么返回函数 a，并且传入参数i+1,sum+i。而如果参数i大于100，则返回参数sum。

当在main.ink函数a的那一刻起，参数i被赋值为1，参数sum被赋值为0，那么由于i满足第一个条件，于是sum变成了0+1，也就是1，而后返回了a(i+1,sum+i)。

接下来，第5行就变成了”1~100的和是:{a(2,1)}“。

看到这里，想必你也清楚了这个循环是如何运作的了，系统将一直调用函数a，且每次传入的值都是上一次调用函数a得到的返回值。如此一来，每当调用一次a，那么它的i就会比上一次调用大1，它的sum就会大sum+i。

而当某一次调用时，i的值大于100，那么这将不满足第一个条件，反而满足了第二个条件，函数a返回了sum，由于返回的是一个参数sum而不是函数a，因此系统将不可能再调用函数a了，转而将”1~100的和是:5050“显示给玩家。



## 隧道式跳转

隧道式跳转是跳转的一种方式，它和节点之间的配合大大丰富了节点的玩法。你可以将这种跳转与节点的关系理解为函数，如果说节点是一个函数，那么隧道式跳转相当于调用函数，它在运用的理念上和函数比较相近，甚至，我们自己创建的函数能够做到的事情，运用隧道式跳转+节点也可以做到，而函数做不到的一些事情，隧道式跳转+节点也可以办到。

当你在一个基本跳转的最后再加一个箭头，一个简单的隧道式跳转就完成一半了，它的格式是：

```
-> <节点名> ->
```

这里还有一种方式，两者之间是等效的：

```
-> <节点1> -> <节点2> -> <节点3> -> ......
//上下两种方式是等效的
-> <节点1> ->
-> <节点2> ->
-> <节点3> ->
.......

```



再在准备跳转到的目标节点内某一位置另起一行，输入两个箭头，当针移动到这里，就可以立即返回跳转发生的位置：(双箭头必须要有，如果你还准备回去。实际上双箭头的作用是告诉计算机，这次隧道式跳转结束了，如果没有双箭头，即使跳转到的节点全部走完，你也不会自动回去，而是直接游戏结束了)

```
== <节点名> ==
...
.....
->->
...
....
```



就拿我制作的文字冒险rpg2来举例，以下是一个用于查看背包信息的节点，几乎所有的场景内，我都需要随时向玩家提供查看背包的功能，那么我不可能在所有的场景下将如此多的一段代码重复n遍，因此在这里我采用了隧道式跳转来解决这个问题。不管故事推进到哪里，只要为玩家提供查看背包的选项，那么针就会跳转到查看背包的节点，显示玩家背包内容，再跳转回原处。

```
//以下是两个使用到查看背包这一功能的不同场景
== battle ==
......
......
+ [使用普通攻击]
...
+ [使用技能]
...
+ [撤退]
...
+ [查看背包]
-> item_pack_examine -> 

-
...

== shop ==
......
......
+ [和老板闲谈]
...
+ [交易]
...
+ [查看背包]
-> item_pack_examine ->
-
...


//以下是用作查看背包的节点，当针来到这个节点，玩家屏幕上就会出现背包内物品信息，而后迅速跳转回跳转发生的地方
== item_pack_examine ==
​```
༺༺༺༺༺༼ 物༣品༣背༣包 ༽༻༻༻༻༻
⓪。。『{item_pack_number_to_text(0)}』X {2d_get(item_pack,0,2,10)}
①。。『{item_pack_number_to_text(1)}』X {2d_get(item_pack,1,2,10)}
②。。『{item_pack_number_to_text(2)}』X {2d_get(item_pack,2,2,10)}
③。。『{item_pack_number_to_text(3)}』X {2d_get(item_pack,3,2,10)}
④。。『{item_pack_number_to_text(4)}』X {2d_get(item_pack,4,2,10)}
⑤。。『{item_pack_number_to_text(5)}』X {2d_get(item_pack,5,2,10)}
⑥。。『{item_pack_number_to_text(6)}』X {2d_get(item_pack,6,2,10)}
⑦。。『{item_pack_number_to_text(7)}』X {2d_get(item_pack,7,2,10)}
⑧。。『{item_pack_number_to_text(8)}』X {2d_get(item_pack,8,2,10)}
⑨。。『{item_pack_number_to_text(9)}』X {2d_get(item_pack,9,2,10)}
༶༶༶༶༶༶༶༶༶༶༶༶༶༶༶༶༶༺装备栏༻༶༶༶༶༶༶༶༶༶༶༶༶༶༶༶
❶  名称：。。『{item_pack_number_to_text(10)}』
    等级：。。{2d_get(item_pack,10,5,10)}
    效果：。。<>
{2d_get(item_pack,10,6,10):
  - 1:物理攻击+
  - 2:魔法攻击+
  - 3:物理防御+
  - 4:魔法防御+
} <>
{2d_get(item_pack,10,7,10)}
    潜力：。。{2d_get(item_pack,10,8,10)}%
.....................................
❷  名称：。。『{item_pack_number_to_text(11)}』
    等级：。。{2d_get(item_pack,11,5,10)}
    效果：。。<>
{2d_get(item_pack,11,6,10):
  - 1:物理攻击+
  - 2:魔法攻击+
  - 3:物理防御+
  - 4:魔法防御+
} <>
{2d_get(item_pack,11,7,10)}
     潜力：。。{2d_get(item_pack,11,8,10)}%
༶༶༶༶༶༶༶༶༶༶༶༶༶༶༶༶༶༺金币量༻༶༶༶༶༶༶༶༶༶༶༶༶༶༶༶
金币：{get(player_information,20)}
༺༓༻༓༺༓༻༓༺༓༻༓༺༓༻༓༺༓༻༓༺༓༻
​```
->->   //当针来到这里，就会跳转回原来的地方
```





值得注意的是，隧道式跳转是可以嵌套的，每当针移到发起隧道跳转的一行，针就会记录那次的目标，如果接着遇到发起隧道跳转，就将这次的目标排到上一次的前面。当针移动到返回跳转发起地的一行（也就是双箭头->->），那么针就会回到排在最前面的那个目标位置，以此类推。

你可以利用这点做出如下复杂的结构：（为了方便理解，这里的节点名字用中文，实际上不能用中文）

```
......
......
+ 发起交易
-> 交易流程 ->
-
......


== 交易流程 ==
+ 买
-> 买东西 ->
+ 卖
-> 卖东西 ->
+ 返回
->->

== 买东西 ==
-> 查看背包 -> 
-> 选择对象物品栏 ->
-> 选择背包物品栏 ->
-> 买入判断 ->
->->

== 卖东西 ==
-> 查看背包 -> 
-> 选择背包物品栏 ->
-> 卖出判断 ->
->->

== 查看背包 ==
......
......
......
->->

== 选择背包物品栏 ==
+ 物品栏1
...
+ 物品栏2
...
+ 物品栏3
...
-
...
...
->->

== 选择对象物品栏 ==
+ 物品栏1
...
+ 物品栏2
...
+ 物品栏3
...
-
...
...
->->

== 买入判断 ==
{ ....:
     .....
     .....
     -> 购买成功操作 ->
     ->->
  else:
     .....
     .....
     -> 购买失败操作->
     ->->     
 }
 
== 卖出判断 ==
{ ....:
     .....
     .....
     -> 卖出成功操作 ->
     ->->
  else:
     .....
     .....
     -> 卖出失败操作->
     ->->     
 }
 
 
== 购买成功操作 ==
......
......
......
->->

== 卖出成功操作 ==
......
......
......
->->

== 购买失败操作 ==
......
......
......
->->

== 卖出失败操作 ==
......
......
......
->->


```



看到这里，想必你也应该明白，越是强大的功能，越是复杂的游戏机制，就越是需要前期的规划，否则你可能脑袋一团乱麻，不知道自己在写什么，陷入无穷尽的调试之中。







