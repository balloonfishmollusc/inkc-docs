# 4.临时变量，节点传参

本篇将讲述除了全局变量外的另一种变量--临时变量，以及和其配套的节点传参



## 临时变量

临时变量用  ~ temp <变量名>  进行定义。变量名最好不要和任何变量，参数，函数，节点重名。

临时变量和参数有一些相似，它们的作用域都不是全局，一个临时变量的作用域就是  从定义它的那一行开始，至定义它的那一行所在的节点或函数的最后一行结束。

> *请注意：
>
> 定义在节点的临时变量，若发生跳转（包括跳转到自身的循环），则在此之前在该节点定义的临时变量将失效，即使再次跳转回原处也没有用了。除此之外，在该节点引用的函数内，使用该节点定义的临时变量不会起作用，你必须利用参数将变量的值传进函数内。
>
> 定义在函数内的临时变量，在该函数引用的函数内（包括引用自身的循环），之前定义的临时变量不会起作用，你必须利用参数将变量的值传进函数内。

在大多数情况下，临时变量被当作储存寿命很短的数据的工具，而不是像全局变量一样用于储存整个游戏都用得到的游戏记录。

## 节点传参

和函数相似，节点也可以定义和传入参数，参数的可用类型与函数一样。

其定义方法如下：

```
==  <节点名>(参数1，参数2，....) ==
```

在跳转时，可以用和引用函数相同的方法来传入参数：

```
-> a(1,2)

== a(x,y) ==
单词one代表{x}，two代表{y}

```

同函数一样，我们也可以通过在节点内跳转会本节点的方法来实现循环，而当加入了用以记录循环次数的参数之后，这类循环的适用性会更加广泛：

```
-> recycle(0)

== recycle(i) ==
{i<=100:
     第{i}次循环
     -> recycle(i+1)
 else:
     -> next
}

== next ==
...
...
```



而当临时变量的值能够通过传入参数的形式进入到其他的节点时，其作用才会被完全发挥出来。

```
== init(x,y) ==
~ temp a = 0
~ temp b = 0

+ 选择a
-> init(a+1,b)
+ 选择b
-> init(a,b+1)
+ 结束
-> show(a,b)

== show(x,y) ==
点了a{x}次，点了b{y}次

```



同函数不一样的是，节点传参还能够传递跳转目标，但若要真正让其发挥作用，那么其格式与其余数据类型的参数有所不同。

如果你想让一个节点的某个参数具有参与到跳转的能力，那么你得在定义时为其加上一个箭头：

```
== a(-> x) ==
```

使用时，传入跳转目标，再在该节点内使用跳转符号就可以进行跳转：

```
-> a(-> b)

== a(-> x) ==
-> x

== b ==
...
...
```

当然，若传入的是其他的数据类型，那么其也是可以正常使用的：

```
-> a(123)

== a(-> x) ==
传入的值是{x}

```



值得注意的是，你可能会感到迷惑，难道这里不应该是 “传入的值是{->x}" 吗？为什么在输出这个参数的时候，需要将这个箭头去掉呢？

下面会讲一个比较重要的概念，即关于箭头”->"在不同语句中的作用也是不同的。



在ink中，数据类型除了整数，浮点数，字符串等等，其实还包括跳转目标这个数据类型，在定义变量时，你甚至可以给变量的值赋值为一个跳转目标

```
VAR a = -> init
-> a
== init ==
...
...
```

你可以尝试输出一个跳转目标，来和其他的数据类型比较一下：

```
VAR a = -> init
{a}
```

总之，当箭头在一个值的内部时，箭头和它后面的东西将构成一个整体——跳转目标。



而当箭头没有被用于赋值，传参等行为时，它就是跳转符。和跳转目标中的箭头不同，跳转符和其后面的节点名并不是一个整体，跳转符是让系统进行跳转的命令，而跳转目标则是一个地址。

如此一来，当跳转符的后面有跳转地址，系统就可以进行跳转了，这也就是上面变量和参数之所以能够参与跳转的原因。



特殊地，在节点传参中，你需要为参数加一个箭头来注明这个参数可以参与跳转，这里的箭头仅仅是一个标记，它和后面的参数名也不是一个整体。



那么现在，你能分清以下代码的含义了吗？

```
-> a(-> b )

== a(-> x) ==
{x}
-> x(123)

== b(y) ==
{y}
```

这里你肯定注意到第5行的 “-> x(123)” 。没错，其实有参数或者变量作为跳转目标的一次跳转，也是可以传参的!



接下来，我想身为大聪明的你一定会去尝试将代码改成这样：

```
-> a(-> b(123) )

== a(-> x) ==
{x}
-> x

== b(y) ==
{y}
```

然而，这样的传参是不被允许的，最主要的原因是：跳转目标不允许携带传入参数的信息。

因此，以下行为当然也是不被允许的：

```
VAR m = -> a(123)
```

总之，传参行为只能发生在跳转符之后衔接的第一个跳转目标中，因为传参这种行为其实属于跳转命令的语法结构

```
-> <跳转目标>(传入参数1，传入参数2，。。。)
```



